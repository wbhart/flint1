% (C) 2007, William Hart, David Harvey
%   This file is part of FLINT.

%   FLINT is free software; you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation; either version 2 of the License, or
%   (at your option) any later version.

%   FLINT is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.

%   You should have received a copy of the GNU General Public License
%   along with FLINT; if not, write to the Free Software
%   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{wrapfig}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{w.b.hart@maths.warwick.ac.uk}

\title{FLINT 1.1: Fast Library for Number Theory}
\author{William B. Hart and David Harvey}

\begin{document}
\maketitle
\lstset{language=c}
\lstset{basicstyle=\ttfamily}
\lstset{keywordstyle=}
%\lstset{morekeywords={mpz_t,mpz_poly_t,fmpz_poly_t}}
\lstset{escapeinside=\%\%}

\section{Introduction}

FLINT is a C library of functions for doing number theory. It is highly optimised and can be compiled on numerous platforms. FLINT also has the aim of providing support for multicore and multiprocessor computer architectures, though we do not yet provide this facility.

FLINT is currently maintained by William Hart of Warwick University in the UK and David Harvey of Harvard University in the US.

As of version 1.0, FLINT compiles on and supports 32 and 64 bit x86 processors, the G5 and Alpha processors, though in theory it compiles on any machine with gcc version 3.4 or later and with GMP version 4.2.1 or later.

FLINT is supplied as a set of modules, \code{fmpz}, \code{fmpz_poly}, etc., each of which can be linked to a C program making use of their functionality. 

All of the functions in FLINT have a corresponding test function provided in an appropriately named test file, e.g: all the functions in the file \code{fmpz_poly.c} have test functions in the file \code{fmpz_poly-test.c}.

\section{Building and using FLINT}

The easiest way to use FLINT is to build a shared library. Simply download the FLINT tarball and untar it on your system.

Next, set the environment variables \code{FLINT_GMP_LIB_DIR} and \code{FLINT_GMP_INCLUDE_DIR} to point to your GMP library and include directories respectively. Similarly, set the environment variables \code{FLINT_NTL_LIB_DIR} and \code{FLINT_NTL_INCLUDE_DIR} to point to your NTL library and include directories respectively. 

Next type:

\code{source flint_env}

in the main directory of the FLINT directory tree. 

Finally type:

\code{make library}

Move the library file \code{libflint.so}, \code{libflint.dll} or \code{libflint.dylib} (depending on your platform) into your library path and move all the .h files in the main directory of FLINT into your include path.

Now to use FLINT, simply include the appropriate header files for the FLINT modules you wish to use in your C program. Then compile your program, linking against the FLINT library and GMP with the options \code{-lflint -lgmp}.

If you are using the NTL-interface, you will also need to link against NTL with the \code{-lntl} linker option.

\section{Test code}
Each module of FLINT has an extensive associated test module. We strongly recommend running the test programs before relying on results from FLINT on your system. 

To make the test programs, simply type:

\code{make test}

in the main FLINT directory.

The following is a list of the test programs which should be run:

\code{mpn_extras-test}

\code{fmpz_poly-test}

\code{fmpz-test}

\code{ZmodF-test}

\code{ZmodF_poly-test}

\code{mpz_poly-test}

\code{ZmodF_mul-test}

\code{long_extras-test}

\code{zmod_poly-test}

\code{NTL-interface-test}

\section{Reporting bugs}
The maintainers wish to be made aware of any and all bugs. Please send an email with your bug report to hart\_wb@yahoo.com.

If possible please include details of your system, version of gcc, version of GMP and precise details of how to replicate the bug.

Note that FLINT needs to be linked against version 4.2.1 or later of GMP and must be compiled with gcc version 3.4 or later.

\section{Example programs}

FLINT comes with a number of example programs to demonstrate current and future FLINT features. To make the example programs, type:

\code{make examples}

The current example programs are:

\code{delta_qexp} Compute the first $n$ terms of the delta function, e.g. \code{delta_qexp 1000000} will compute the first one million terms of the $q$-expansion of delta.

\code{BPTJCubes} Implements the algorithm of Beck, Pine, Tarrant and Jensen for finding solutions to the equation $x^3+y^3+z^3 = k$.

\code{bernoulli_zmod} Compute bernoulli numbers modulo a large number of primes.

\code{expmod} Computes a very large modular exponentiation.

\section{FLINT macros}
In the file flint.h are various useful macros.

The macro constant \code{FLINT_BITS} is set at compile time to be the number of bits per limb on the machine. FLINT requires it to be either 32 or 64 bits. Other architectures are not currently supported.

The macro constant \code{FLINT_D_BITS} is set at compile time to be the number of bits per double on the machine or the number of bits per limb, whichever is smaller. This will have the value 53 or 32 on currently supported architectures. Numerous functions using precomputed inverses only support operands up to \code{FLINT_D_BITS - 1} bits, hence the macro.

\code{FLINT_ABS(x)} returns the absolute value of a \code{long x}.

\code{FLINT_MIN(x, y)} returns the minimum of two \code{long} or two \code{unsigned long} values \code{x} and \code{y}.

\code{FLINT_MAX(x, y)} returns the maximum of two \code{long} or two \code{unsigned long} values \code{x} and \code{y}.

\code{FLINT_BIT_COUNT(x)} returns the number of binary bits required to represent an \code{unsigned long x}.

\section{The fmpz\_poly module}

The \code{fmpz_poly_t} data type represents elements of $\Z[x]$. The \code{fmpz_poly} module provides routines for memory management, basic arithmetic, and conversions to/from other types.

Each coefficient of an \code{fmpz_poly_t} is an integer of the FLINT \code{fmpz_t} type. 

Unless otherwise specified, all functions in this section permit aliasing between their input arguments and between their input and output arguments. 

\subsection{Simple example}

The following example computes the square of the polynomial $5x^3 - 1$.

\begin{lstlisting}
#include "fmpz_poly.h"
 ....
fmpz_poly_t x, y;
fmpz_poly_init(x);
fmpz_poly_init(y);
fmpz_poly_set_coeff_ui(x, 3, 5);
fmpz_poly_set_coeff_si(x, 0, -1);
fmpz_poly_mul(y, x, x);
fmpz_poly_print(x); printf("\n");
fmpz_poly_print(y); printf("\n");
fmpz_poly_clear(x);
fmpz_poly_clear(y);
\end{lstlisting}

The output is:

\begin{lstlisting}
4  -1 0 0 5
7  1 0 0 -10 0 0 25
\end{lstlisting}

\subsection{Definition of the \code{fmpz} polynomial type}

The \code{fmpz_poly_t} type is a typedef for an array of length 1 of \code{fmpz_poly_struct}'s. This permits passing parameters  of type \code{fmpz_poly_t} `by reference' in a manner similar to the way GMP integers of type \code{mpz_t} can be passed by reference. 

In reality one never deals directly with the struct and simply deals with objects of type \code{fmpz_poly_t}. For simplicity we will think of an \code{fmpz_poly_t} as a struct, though in practice to access fields of this struct, one needs to dereference first, e.g. to access the \code{length} field of an \code{fmpz_poly_t} called \code{poly1} one writes \code{poly1->length}. 

An \code{fmpz_poly_t} is said to be \emph{normalised} if either \code{length == 0}, or if the final coefficient is nonzero. All \code{fmpz_poly} functions expect their inputs to be normalised, and unless otherwise specified they produce output that is normalised. 

It is recommended that users do not access the fields of an \code{fmpz_poly_t} or its coefficient data directly, but make use of the functions designed for this purpose (detailed below).

Functions in \code{fmpz_poly} do all the memory management for the user. One does not need to specify the maximum length or number of limbs per coefficient in advance before using a polynomial object. FLINT reallocates space automatically as the computation proceeds, if more space is required. 

We now describe the functions available in \code{fmpz_poly}.

\subsection{Initialisation and memory management}

\begin{lstlisting}
void fmpz_poly_init(fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Initialise an \code{fmpz_poly_t} for use. The length of \code{poly} is set to zero. A corresponding call to \code{fmpz_poly_clear} must be made after finishing with the \code{fmpz_poly_t} to free the memory used by the polynomial.

For efficiency reasons, a call to \code{fmpz_poly_init} does not actually allocate any memory for coefficients. Each of the functions will automatically allocate any space needed for coefficients and in fact the easiest way to use \code{fmpz_poly} is to let FLINT do all the allocation automatically. 

To this end, a user need only ever make calls to the \code{fmpz_poly_init} and \code{fmpz_poly_clear} memory management functions if they so wish. Naturally, more efficient code may result if the other memory management functions are also used.
\end{quote}

\begin{lstlisting}
void fmpz_poly_realloc(fmpz_poly_t poly, unsigned long alloc)
\end{lstlisting}
\begin{quote}
Shrink or expand the polynomial so that it has space for precisely \code{alloc} coefficients. If \code{alloc} is less than the current length, the polynomial is truncated (and then normalised), otherwise the coefficients and current length remain unaffected. 

If the parameter \code{alloc} is zero, any space currently allocated for coefficients in \code{poly} is free'd. A subsequent call to \code{fmpz_poly_clear} is still permitted and does nothing.
\end{quote}

\begin{lstlisting}
void fmpz_poly_fit_length(fmpz_poly_t poly, unsigned long alloc)
\end{lstlisting}
\begin{quote}
Expand the polynomial (if necessary) so that it has space for at least \code{alloc} coefficients. This function will never shrink the memory allocated for coefficients and the contents of the existing coefficients and the current length remain unaffected. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_clear(fmpz_poly_t poly)\end{lstlisting}
\begin{quote}
Free all memory used by the coefficients of \code{poly}. The polynomial object \code{poly} cannot be used again until a subsequent call to an initialisation function is made.
\end{quote}

\subsection{Setting/retrieving coefficients}

\begin{lstlisting}
void fmpz_poly_get_coeff_mpz(mpz_t x, const fmpz_poly_t poly, 
                                                 unsigned long n)
\end{lstlisting}
\begin{quote}
Retrieve coefficient $n$ as an \code{mpz_t}. 

Coefficients are numbered from zero, starting with the constant coefficient.

Sets \code{x} to zero when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_get_coeff_mpz_read_only(mpz_t x, 
                         const fmpz_poly_t poly, unsigned long n)
\end{lstlisting}
\begin{quote}
Retrieve coefficient $n$ as a read only \code{mpz_t}. The function must be passed an uninitialised \code{mpz_t}. The \code{mpz_t} can then be used as an input to a GMP functions, but not as an output. Its contents may be inspected, but not alterered. This function is faster than \code{fmpz_poly_get_coeff_mpz} which makes an extra copy of the data. 

Coefficients are numbered from zero, starting with the constant coefficient.

Sets \code{x} to zero when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_set_coeff_mpz(fmpz_poly_t poly, unsigned long n, 
                                                            mpz_t x) 
\end{lstlisting}
\begin{quote}
Set coefficient $n$ to the value of the given \code{mpz_t}. 

Coefficients are numbered from zero, starting with the constant coefficient. If $n$ represents a coefficient beyond the current length of \code{poly}, zero coefficients are added in between the existing coefficients and the new coefficient, if required.
\end{quote}

\begin{lstlisting}
void fmpz_poly_get_coeff_fmpz(fmpz_t x, const fmpz_poly_t poly, 
                                                 unsigned long n)
\end{lstlisting}
\begin{quote}
Retrieve coefficient $n$ as an \code{fmpz_t}. 

Coefficients are numbered from zero, starting with the constant coefficient.

Sets \code{x} to zero when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_set_coeff_fmpz(fmpz_poly_t poly, unsigned long n, 
                                                           fmpz_t x) 
\end{lstlisting}
\begin{quote}
Set coefficient $n$ to the value of the given \code{fmpz_t}. 

Coefficients are numbered from zero, starting with the constant coefficient. If $n$ represents a coefficient beyond the current length of \code{poly}, zero coefficients are added in between the existing coefficients and the new coefficient, if required.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_poly_get_coeff_ui(const fmpz_poly_t poly, 
                                                 unsigned long n)
\end{lstlisting}
\begin{quote}
Return the absolute value of coefficient $n$ as an \code{unsigned long}.

Coefficients are numbered from zero, starting with the constant coefficient. If the coefficient is longer than a single limb, the first limb is returned.

Returns zero when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_set_coeff_ui(fmpz_poly_t poly, unsigned long n, 
                                                    unsigned long x) 
\end{lstlisting}
\begin{quote}
Set coefficient $n$ to the value of the given \code{unsigned long}. 

Coefficients are numbered from zero, starting with the constant coefficient. If $n$ represents a coefficient beyond the current length of \code{poly}, zero coefficients are added in between the existing coefficients and the new coefficient, if required.
\end{quote}

\begin{lstlisting}
long fmpz_poly_get_coeff_si(const fmpz_poly_t poly, unsigned long n)
\end{lstlisting}
\begin{quote}
Return the value of coefficient $n$ as a \code{long}.

Coefficients are numbered from zero, starting with the constant coefficient. If the coefficient will not fit into a \code{long}, i.e. if its absolute value takes up more than \code{FLINT_BITS - 1} bits then the result is undefined.

Returns zero when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_set_coeff_si(fmpz_poly_t poly, unsigned long n, long x) 
\end{lstlisting}
\begin{quote}
Set coefficient $n$ to the value of the given \code{long}. 

Coefficients are numbered from zero, starting with the constant coefficient. If $n$ represents a coefficient beyond the current length of \code{poly}, zero coefficients are added in between the existing coefficients and the new coefficient, if required.
\end{quote}

\begin{lstlisting}
fmpz_t fmpz_poly_get_coeff_ptr(fmpz_poly_t poly, unsigned long n)
\end{lstlisting}
\begin{quote}
Return a reference to coefficient $n$ (as an \code{fmpz_t}). This function is provided so that individual coefficients can be accessed and operated on by functions in the \code{fmpz} module. This function does not make a copy of the data, but returns a reference to the actual coefficient.

Coefficients are numbered from zero, starting with the constant coefficient. 

Returns NULL when $n >= $ \code{poly->length}. 
\end{quote}

\begin{lstlisting}
fmpz_t fmpz_poly_lead(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Return a reference to leading coefficient (as an \code{fmpz_t}) of \code{poly}. This function is provided so that the leading coefficient can be easily accessed and operated on by functions in the \code{fmpz} module. This function does not make a copy of the data, but returns a reference to the actual coefficient.

Returns NULL when the polynomial has length zero. 
\end{quote}

\subsection{String conversions and I/O}

The functions in this section are not intended to be particularly fast. They are intended mainly as a debugging aid.

For the string output functions there are two variants. The first uses a simple string representation of polynomials which prints only the length of the polynomial and the integer coefficients, whilst the latter variant (appended with \code{_pretty}) uses a more traditional string representation of polynomials which prints a variable name as part of the representation. 

The first string representation is given by a sequence of integers, in decimal notation, separated by whitespace. The first integer gives the length of the polynomial; the remaining \code{length} integers are the coefficients. For example $5x^3 - x + 1$ is represented by the string ``\code{4 1 -1 0 5}'', and the zero polynomial is represented by ``\code{0}''. The coefficients may be signed and arbitrary precision.

The string representation of the functions appended by \code{_pretty} includes only the non-zero terms of the polynomial, starting with the one of highest degree. Each term starts with a coefficient, prepended with a sign (positive or negative), followed by the character \code{*}, followed by a variable name, which must be passed as a string parameter to the function, followed by a carot \code{^} followed by a non-negative exponent.

If the sign of the leading coefficient is positive, it is omitted. Also the exponents of the degree 1 and 0 terms are omitted, as is the variable and the \code{*} character in the case of the degree 0 coefficient. If the coefficient is plus or minus one, the coefficient is omitted, except for the sign.

Some examples of the \code{_pretty} representation are:

\begin{lstlisting}
5*x^3+7*x-4
x^2+3
-x^4+2*x-1
x+1
5
\end{lstlisting}

\begin{lstlisting}
int fmpz_poly_from_string(fmpz_poly_t poly, const char* s)
\end{lstlisting}
\begin{quote}
Import a polynomial from a string. If the string represents a valid polynomial the function returns 1, otherwise it returns 0.
\end{quote}

\begin{lstlisting}
char* fmpz_poly_to_string(const fmpz_poly_t poly)
char* fmpz_poly_to_string_pretty(const fmpz_poly_t poly, 
                                                      const char * x)
\end{lstlisting}
\begin{quote}
Convert a polynomial to a string and return a pointer to the string. Space is allocated for the string by this function and must be freed when it is no longer used, by a call to \code{free}.

The \code{pretty} version must be supplied with a string \code{x} which represents the variable name to be used when printing the polynomial.
\end{quote}

\begin{lstlisting}
void fmpz_poly_fprint(const fmpz_poly_t poly, FILE* f)
void fmpz_poly_fprint_pretty(const fmpz_poly_t poly, FILE* f, 
                                                      const char * x)
\end{lstlisting}
\begin{quote}
Convert a polynomial to a string and write it to the given stream. 

The \code{pretty} version must be supplied with a string \code{x} which represents the variable name to be used when printing the polynomial.
\end{quote}

\begin{lstlisting}
void fmpz_poly_print(const fmpz_poly_t poly)
void fmpz_poly_print_pretty(const fmpz_poly_t poly, const char * x)
\end{lstlisting}
\begin{quote}
Convert a polynomial to a string and write it to \code{stdout}. 

The \code{pretty} version must be supplied with a string \code{x} which represents the variable name to be used when printing the polynomial.
\end{quote}

\begin{lstlisting}
void fmpz_poly_fread(fmpz_poly_t poly, FILE* f)
\end{lstlisting}
\begin{quote}
Read a polynomial from the given stream. Return 1 if the data from the stream represented a valid polynomial, otherwise return 0.
\end{quote}

\begin{lstlisting}
void fmpz_poly_read(fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Read a polynomial from \code{stdin}. Return 1 if the data read from \code{stdin} represented a valid polynomial, otherwise return 0.
\end{quote}

\subsection{Polynomial parameters (length, degree, limbs, etc.)}

\begin{lstlisting}
long fmpz_poly_degree(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Return \code{poly->length - 1}. The zero polynomial is defined to have degree $-1$.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_poly_length(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Return \code{poly->length}. The zero polynomial is defined to have length $0$.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_poly_max_limbs(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Returns the maximum number of limbs required to store the absolute value of coefficients of \code{poly}. \end{quote}

\begin{lstlisting}
long fmpz_poly_max_bits(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Computes the maximum number of bits $b$ required to store the absolute value of coefficients of \code{poly}. If all the coefficients of \code{poly} are non-negative, $b$ is returned, otherwise $-b$ is returned. \end{quote}

\begin{lstlisting}
long fmpz_poly_max_bits1(const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Computes the maximum number of bits $b$ required to store the absolute value of coefficients of \code{poly}. If all the coefficients of \code{poly} are non-negative, $b$ is returned, otherwise $-b$ is returned. 

The assumption is made that the absolute value of each coefficient fits into an unsigned long. This function will be more efficient than the more general \code{fmpz_poly_max_bits} in this situation.
\end{quote}


\subsection{Assignment and basic manipulation}

\begin{lstlisting}
void fmpz_poly_set(fmpz_poly_t output, const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Set polynomial \code{output} equal to the polynomial \code{poly}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_swap(fmpz_poly_t poly1, fmpz_poly_t poly2)
\end{lstlisting}
\begin{quote}
Efficiently swap two polynomials. The coefficients are not moved in memory, pointers are simply switched. \end{quote}

\begin{lstlisting}
void fmpz_poly_zero(fmpz_poly_t poly) 
\end{lstlisting}
\begin{quote}
Set the polynomial to the zero polynomial.
\end{quote}

\begin{lstlisting}
void fmpz_poly_zero_coeffs(fmpz_poly_t poly, unsigned long n) 
\end{lstlisting}
\begin{quote}
Set the first $n$ coefficients of \code{poly} to zero. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_neg(fmpz_poly_t output, fmpz_poly_t poly) 
\end{lstlisting}
\begin{quote}
Negate the polynomial \code{poly}, i.e. set \code{output} to \code{-poly}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_truncate(fmpz_poly_t poly, const unsigned long trunc)
\end{lstlisting}
\begin{quote}
If \code{trunc} is less than the current length of the polynomial, truncate the polynomial to that length. Note that as the function normalises its output, the eventual length of the polynomial may be less than \code{trunc}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_reverse(fmpz_poly_t output, const fmpz_poly_t poly,  
                                                  unsigned long length) 
\end{lstlisting}
\begin{quote}
This function considers the polynomial \code{poly} to be of length $n$, notionally truncating and zero padding if required, and reverses the result. Since this function normalises its result the eventual length of \code{output} may be less than \code{length}.
\end{quote}

\subsection{Conversions}

\begin{lstlisting}
void fmpz_poly_to_zmod_poly(zmod_poly_t zpol, fmpz_poly_t fpol)
\end{lstlisting}
\begin{quote}
Reduce each of the coefficients of the \code{fmpz_poly_t fpol} modulo the modulus of the \code{zmod_poly_t zpol} and store the result in \code{zpol}.

This function is provided to enable the implementation of multimodular algorithms.
\end{quote}

\begin{lstlisting}
void zmod_poly_to_fmpz_poly_unsigned(fmpz_poly_t fpol, zmod_poly_t zpol)\end{lstlisting}
\begin{quote}
Convert the \code{zmod_poly_t zpol} to an \code{fmpz_poly_t}. The coefficients of the resulting \code{fmpz_poly_t} will all be unsigned.
\end{quote}

\begin{lstlisting}
void zmod_poly_to_fmpz_poly(fmpz_poly_t fpol, zmod_poly_t zpol)\end{lstlisting}
\begin{quote}
Convert the \code{zmod_poly_t zpol} to an \code{fmpz_poly_t}. If \code{p} is the modulus of \code{zpol} then coefficients which lie in $[0, p/2]$ are unchanged, however, coefficients $a$ in the range $(p/2, p)$ become $a - p$.

This function is provided to enable the implementation of multimodular algorithms.
\end{quote}

\subsection{Chinese remaindering}

\begin{lstlisting}
int fmpz_poly_CRT_unsigned(fmpz_poly_t res, fmpz_poly_t fpol, 
                     zmod_poly_t zpol, fmpz_t newmod, fmpz_t oldmod)
\end{lstlisting}
\begin{quote}
Performs modular recombination using the Chinese Remainder Theorem. If \code{zpol} has modulus $p$, \code{newmod} is set equal to \code{oldmod*p} and each coefficient of \code{res} is set to the unique value modulo \code{newmod}, in the range $[0, \mbox{newmod})$ which is $a$ modulo \code{oldmod} and $b$ modulo $p$, where $a$ is the coefficient of \code{fpol} and $b$ is the corresponding coefficient of \code{zpol}.

The coefficients of \code{fpol} are assumed to be unsigned. 
\end{quote}

\begin{lstlisting}
int fmpz_poly_CRT(fmpz_poly_t res, fmpz_poly_t fpol, 
                     zmod_poly_t zpol, fmpz_t newmod, fmpz_t oldmod)
\end{lstlisting}
\begin{quote}
Performs modular recombination using the Chinese Remainder Theorem. If \code{zpol} has modulus $p$, \code{newmod} is set equal to \code{oldmod*p} and each coefficient of \code{res} is set to the unique value modulo \code{newmod}, in the range $(-\mbox{newmod}/2, \mbox{newmod}/2]$ which is $a$ modulo \code{oldmod} and $b$ modulo $p$, where $a$ is the coefficient of \code{fpol} and $b$ is the corresponding coefficient of \code{zpol}. 
\end{quote}

\subsection{Comparison}


\begin{lstlisting}
int fmpz_poly_equal(const fmpz_poly_t poly1, const fmpz_poly_t poly2) 
\end{lstlisting}
\begin{quote}
Return 1 if the two polynomials are equal, 0 otherwise.
\end{quote}


\subsection{Shifting}

\begin{lstlisting}
void fmpz_poly_left_shift(fmpz_poly_t output, 
                             const fmpz_poly_t poly, unsigned long n) 
\end{lstlisting}
\begin{quote}
Shift poly to the left by $n$ coefficients (multiply by $x^n$) and write the result to \code{output}. Zero coefficients are inserted.

The parameter $n$ must be non-negative, but can be zero.
\end{quote}

\begin{lstlisting}
void fmpz_poly_right_shift(fmpz_poly_t output, 
                             const fmpz_poly_t poly, unsigned long n) 
\end{lstlisting}
\begin{quote}
Shift poly to the right by $n$ coefficients (divide by $x^n$ and discard the remainder) and write the result to \code{output}. 

The parameter $n$ must be non-negative, but can be zero. Shifting right by more than the current length of the polynomial results in the zero polynomial.
\end{quote}


\subsection{Norms}

\begin{lstlisting}
void fmpz_poly_2norm(fmpz_t norm, fmpz_poly_t pol)\end{lstlisting}
\begin{quote}
Sets \code{norm} to the euclidean norm of \code{pol}, i.e. the integer square root of the sum of the squares of the coefficients of \code{pol}.
\end{quote}


\subsection{Addition/subtraction}


\begin{lstlisting}
void fmpz_poly_add(fmpz_poly_t output, const fmpz_poly_t poly1, 
                                              const fmpz_poly_t poly2) 
\end{lstlisting}
\begin{quote}
Set the output to the sum of the input polynomials. 

Note that if \code{poly1} and \code{poly2} have the same length, cancellation may occur (if the leading coefficients have the same absolute values but opposite signs) and so the result may have less coefficients than either of the inputs. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_sub(fmpz_poly_t output, const fmpz_poly_t poly1, 
                                              const fmpz_poly_t poly2) 
\end{lstlisting}
\begin{quote}
Set the output to \code{poly1 - poly2}. 

Note that if \code{poly1} and \code{poly2} have the same length, cancellation may occur (if the leading coefficients have the same values) and so the result may have less coefficients than either of the inputs. 
\end{quote}

\subsection{Scalar multiplication and division}

\begin{lstlisting}
void fmpz_poly_scalar_mul_ui(fmpz_poly_t output, 
                               const fmpz_poly_t poly, unsigned long x)
\end{lstlisting}
\begin{quote}
Multiply \code{poly} by the \code{unsigned long x} and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_mul_si(fmpz_poly_t output, 
                                        const fmpz_poly_t poly, long x)
\end{lstlisting}
\begin{quote}
Multiply \code{poly} by the \code{long x} and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_mul_fmpz(fmpz_poly_t output, 
                                const fmpz_poly_t poly, const fmpz_t x) 
\end{lstlisting}
\begin{quote}
Multiply \code{poly} by the \code{fmpz_t x} and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_mul_mpz(fmpz_poly_t output, 
                                const fmpz_poly_t poly, const mpz_t x) 
\end{lstlisting}
\begin{quote}
Multiply \code{poly} by the \code{mpz_t x} and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_ui(fmpz_poly_t output, 
                               const fmpz_poly_t poly, unsigned long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{unsigned long x}, round quotients towards minus infinity, discard remainders and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_si(fmpz_poly_t output, 
                                        const fmpz_poly_t poly, long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{long x}, round quotients towards minus infinity, discard remainders and write the result to \code{output}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_tdiv_ui(fmpz_poly_t output, 
                               const fmpz_poly_t poly, unsigned long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{unsigned long x}, round quotients towards zero, discard remainders and write the result to \code{output}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_tdiv_si(fmpz_poly_t output, 
                                        const fmpz_poly_t poly, long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{long x}, round quotients towards zero, discard remainders and write the result to \code{output}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_exact_ui(fmpz_poly_t output, 
                               const fmpz_poly_t poly, unsigned long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{unsigned long x}. Division is assumed to be exact and the result is undefined otherwise.
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_exact_si(fmpz_poly_t output, 
                                        const fmpz_poly_t poly, long x)
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{long x}. Division is assumed to be exact and the result is undefined otherwise.
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_fmpz(fmpz_poly_t output, 
                                const fmpz_poly_t poly, const fmpz_t x) 
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{fmpz_t x}, round quotients towards minus infinity, discard remainders, and write the result to \code{output}. 
\end{quote}

\begin{lstlisting}
void fmpz_poly_scalar_div_mpz(fmpz_poly_t output, 
                                const fmpz_poly_t poly, const mpz_t x) 
\end{lstlisting}
\begin{quote}
Divide \code{poly} by the \code{mpz_t x}, round quotients towards minus infinity, discard remainders, and write the result to \code{output}. 
\end{quote}

\subsection{Polynomial multiplication}

\begin{lstlisting}
void fmpz_poly_mul(fmpz_poly_t output, const fmpz_poly_t poly1, 
                                              const fmpz_poly_t poly2) 
\end{lstlisting}
\begin{quote}
Multiply the two given polynomials and return the result in \code{output}.

The length of the output polynomial will be \code{poly1->length + poly2->length - 1}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_mul_trunc_n(fmpz_poly_t output, 
     const fmpz_poly_t poly1, const fmpz_poly_t poly2, unsigned long n) 
\end{lstlisting}
\begin{quote}
Multiply the two given polynomials and truncate the result to $n$ coefficients, storing the result in \code{output}. This is sometimes known as a short product.

The length of the output polynomial will be at most the minimum of $n$ and the value \code{poly1->length + poly2->length - 1}. It is permissible to set $n$ to any non-negative value, however the function is optimised for $n$ about half of \code{poly1->length + poly2->length}.

This function is more efficient than multiplying the two polynomials then truncating. It is the operation used when multiplying power series.
\end{quote}

\begin{lstlisting}
void fmpz_poly_mul_trunc_left_n(fmpz_poly_t output, 
     const fmpz_poly_t poly1, const fmpz_poly_t poly2, unsigned long n) 
\end{lstlisting}
\begin{quote}
Multiply the two given polynomials storing the result in \code{output}. This function guarantees all the coefficients except the first $n$, which may be arbitrary. This is sometimes known as an opposite short product.

The length of the output polynomial will be \code{poly1->length + poly2->length - 1} unless $n$ is greater than or equal to this value, in which case it will return the zero polynomial. It is permissible to set $n$ to any non-negative value, however the function is optimised for $n$ about half of \code{poly1->length + poly2->length}.

For short polynomials, this function is more efficient than computing the full product.
\end{quote}

\subsection{Polynomial division}

\begin{lstlisting}
void fmpz_poly_divrem(fmpz_poly_t Q, fmpz_poly_t R, 
                              const fmpz_poly_t A, const fmpz_poly_t B) 
\end{lstlisting}
\begin{quote}
Performs division with remainder in $\Z[x]$. Computes polynomials \code{Q} and \code{R} in $\Z[x]$ such that the equation \code{A = B*Q + R}, holds. All but the final \code{B->length - 1} coefficients of \code{R} will be positive and less than the absolute value of the lead coefficient of \code{B}.

Note that in the special cases where the leading coefficient of \code{B} is $\pm 1$ or \code{A = B*Q} for some polynomial \code{Q}, the result of this function is the same as if the computation had been done over $\Q$.
\end{quote}

\begin{lstlisting}
void fmpz_poly_div(fmpz_poly_t Q, const fmpz_poly_t A, 
                                                   const fmpz_poly_t B) 
\end{lstlisting}
\begin{quote}
Performs division without remainder in $\Z[x]$. The computation returns the same result as \code{fmpz_poly_divrem}, but no remainder is computed. This is in general faster than computing quotient and remainder. 

Note that in the special cases where the leading coefficient of \code{B} is $\pm 1$ or \code{A = B*Q} for some polynomial \code{Q}, the result of this function is the same as if the computation had been done over $\Q$. In particular it can be used efficiently for exact division in $\Z[x]$.
\end{quote}

\begin{lstlisting}
void fmpz_poly_div_series(fmpz_poly_t Q, const fmpz_poly_t A, 
                                  const fmpz_poly_t B, unsigned long n) 
\end{lstlisting}
\begin{quote}
Performs power series division in $\Z[[x]]$. The function considers the polynomials \code{A} and \code{B} to be power series of length $n$ starting with the constant terms. The function assumes that \code{B} is normalised, i.e. that the constant coefficient is $\pm 1$. The result is truncated to length $n$ regardless of the inputs.
\end{quote}

\begin{lstlisting}
int fmpz_poly_divides(fmpz_poly_t Q, fmpz_poly_t A, fmpz_poly_t B)
\end{lstlisting}
\begin{quote}
If the polynomial \code{A} is divisible by the polynomial \code{B} this function returns 1 and sets \code{Q} to the quotient, otherwise it returns 0.

At this point, this function is provided for convenience only; it is not efficient when \code{B} does not actually divide \code{A}. 
\end{quote}

\subsection{Pseudo division}

\begin{lstlisting}
void fmpz_poly_pseudo_divrem(fmpz_poly_t Q, fmpz_poly_t R, 
           unsigned long * d, const fmpz_poly_t A, const fmpz_poly_t B)
\end{lstlisting}
\begin{quote}
Performs division with remainder of two polynomials in $\Z[x]$, notionally returning the results in $\Q[x]$ (actually in $\Z[x]$ with a single common denominator).

Computes polynomials \code{Q} and \code{R} such that \code{lead(B)^d*A = B*Q + R} where \code{R} has degree less than that of \code{B}.

This function may be used to do division of polynomials in $\Q[x]$ as follows. Suppose polynomials \code{C} and \code{D} are given in $\Q[x]$. 

1) Write \code{C = d1*A} and \code{D = d2*B} for some polynomials \code{A} and \code{B} in $\Z[x]$ and integers \code{d1} and \code{d2}.

2) Use pseudo-division to compute \code{Q} and \code{R} in $\Z[x]$ so that \code{l^d*A = B*Q + R} where \code{l} is the leading coefficient of \code{B}. 

3) We can now write \code{C = (d1/d2*D*Q + d1*R)/l^d}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_pseudo_div(fmpz_poly_t Q, unsigned long * d, 
                              const fmpz_poly_t A, const fmpz_poly_t B)
\end{lstlisting}
\begin{quote}
Performs division without remainder of two polynomials in $\Z[x]$, notionally returning the results in $\Q[x]$ (actually in $\Z[x]$ with a single common denominator).

Notionally computes polynomials \code{Q} and \code{R} such that \code{lead(B)^d*A = B*Q + R} where \code{R} has degree less than that of \code{B}, but returns only \code{Q}. This is slightly more efficient than computing the quotient and remainder.
\end{quote}

\subsection{Powering}

\begin{lstlisting}
void fmpz_poly_power(fmpz_poly_t output, const fmpz_poly_t poly, 
                                                     unsigned long exp) 
\end{lstlisting}
\begin{quote}
Raises \code{poly} to the power \code{exp} and writes the result in \code{output}.
\end{quote}

\begin{lstlisting}
void fmpz_poly_power_trunc_n(fmpz_poly_t output, 
            const fmpz_poly_t poly, unsigned long exp, unsigned long n) 
\end{lstlisting}
\begin{quote}
Notionally raises \code{poly} to the power \code{exp}, truncates the result to length $n$ and writes the result in \code{output}. This is computed much more efficiently than simply powering the polynomial and truncating.

This function can be used to raise power series to a power in an efficient way.
\end{quote}

\subsection{Gaussian content}

\begin{lstlisting}
void fmpz_poly_content(fmpz_t c, fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Set the \code{fmpz_t c} to the Gaussian content of the polynomial \code{poly}, i.e. to the greatest common divisor of its coefficients.
\end{quote}

\begin{lstlisting}
void _fmpz_poly_primitive_part(fmpz_poly_t prim, fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Set \code{prim} to the primitive part of the polynomial \code{poly}, i.e. to \code{poly} divided by its Gaussian content.
\end{quote}

\subsection{Greatest common divisor and resultant}
\begin{lstlisting}
void fmpz_poly_gcd(fmpz_poly_t res, const fmpz_poly_t poly1, 
                                             const fmpz_poly_t poly2)
\end{lstlisting}
\begin{quote}
Sets \code{res} to the greatest common divisor of the polynomials \code{poly1} and \code{poly2}.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_poly_resultant_bound(fmpz_poly_t a, fmpz_poly_t b)
void fmpz_poly_resultant(fmpz_t r, fmpz_poly_t a, fmpz_poly_t b)
\end{lstlisting}
\begin{quote}
Compute the resultant of the polynomials \code{a} and \code{b}. If \code{a} and \code{b} are monic with $a(x) = \prod_i (x - \alpha_i)$ and $b(x) = \prod_j (x - \beta_j)$, when factored over the complex numbers, then the resultant is given by the expression $r(x) = \prod_{i,j} (\alpha_i - \beta_j)$. If the polynomials are not monic, and \code{a} and \code{b} have leading coefficients $l_1$ and $l_2$ and degrees $d_1$ and $d_2$ respectively, then this quantity is multiplied by $l_1^{d_2-1}l_2^{d_1-1}$.

Note that the resultant is zero iff the polynomials share a root over the algebraic closure of $\Q$.

Currently it is necessary to ensure \code{r} has sufficient space to store the result. The function \code{fmpz_poly_resultant_bound} is used to determine a bit bound on the number of bits \code{b} required and \code{r} must have space for \code{b/FLINT_BITS + 2} limbs.

In a future version of FLINT, this computation will not be necessary.
\end{quote}

\begin{lstlisting}
void fmpz_poly_xgcd(fmpz_t r, fmpz_poly_t s, fmpz_poly_t t, 
                                          fmpz_poly_t a, fmpz_poly_t b)
\end{lstlisting}
\begin{quote}
Given coprime polynomials \code{a} and \code{b} this function computes polynomials \code{s} and \code{t} and the resultant \code{r} of the polynomials such that \code{r = a*s + b*t}.

See the function \code{fmpz_poly_resultant} for information on how large \code{r} needs to be to hold the result.
\end{quote}

\subsection{Modular arithmetic}
\begin{lstlisting}
void fmpz_poly_invmod(fmpz_t d, fmpz_poly_t H, fmpz_poly_t poly1, 
                                                    fmpz_poly_t poly2)
\end{lstlisting}
\begin{quote}
Computes a polynomial \code{H} and a denominator \code{d} such that \code{poly1*H} is \code{d} modulo \code{poly2}. 

Assumes that \code{poly1} and \code{poly2} are coprime and that \code{poly2} is monic.
\end{quote}

\section{The fmpz module}
The \code{fmpz} module is designed for manipulation of the FLINT flat multiprecision integer format \code{fmpz_t}. 

Internally, the data for an \code{fmpz_t} has first limb a sign/size limb. If it is 0 the integer represented by the \code{fmpz_t} is 0. The absolute value of the sign/size limb is the number of subsequent limbs that the absolute value of the integer being represented, takes up. The absolute value of the integer is then stored as limbs, least significant limb first, in the subsequent limbs after the sign/size limb. If the sign/size limb is positive, a positive integer is intended and if the sign/size limb is negative the negative integer with the stored absolute value is intended.

The \code{fmpz_t} type is not intended as a standalone integer type. It is intended to be used in composite types such as polynomials and matrices which consist of many integer entries. 

Currently the user is responsible for memory management of \code{fmpz_t}'s, i.e. one must ensure that the output of a function in the \code{fmpz} module contains sufficient space to store the result. This will be changed in a later version of FLINT, where automatic memory management will be done for the user. 

To ensure that the correct number of limbs are available in each \code{fmpz_t} of an \code{fmpz_poly_t} one must currently call \code{void fmpz_poly_fit_limbs(fmpz_poly_t pol, unsigned long limbs)}, which will then ensure that each coefficient of \code{pol} has space for at least the given number of limbs (referring to the absolute value of the coefficients). Again, in a later version of FLINT, this step will be unnecessary as automatic memory management will be done for all \code{fmpz_t}'s, including coefficients of \code{fmpz_poly_t}'s.

Note that \code{fmpz_t}'s are not currently guaranteed to allow aliasing between inputs or between inputs and outputs. However some optimised inplace functions are provided.

\subsection{A simple example}
We start with a simple example of the use of the \code{fmpz} module.

This example sets $x$ to 3 and adds 5 to it.

\begin{lstlisting}
#include "fmpz.h"
 ....
fmpz_t x = fmpz_init(1); // Allocate 1 limb of space
fmpz_set_ui(x, 3);
fmpz_add_ui_inplace(x, 5);
printf("3 + 5 is "); fmpz_print(x); printf("\n");
fmpz_clear(x);
\end{lstlisting}

We now discuss the functions available in the \code{fmpz} module.

\subsection{Memory management}

\begin{lstlisting}
fmpz_t fmpz_init(unsigned long limbs) 
\end{lstlisting}
\begin{quote}
Allocates space for an \code{fmpz_t} with the given number of limbs (plus an additional limb for the sign/size) on the heap and return a pointer to the space.
\end{quote}

\begin{lstlisting}
fmpz_t fmpz_realloc(fmpz_t f, unsigned long limbs)
\end{lstlisting}
\begin{quote}
Reallocate the space used by the \code{fmpz_t f} so that it has space for the given number of limbs (plus a sign/size limb). The parameter \code{limbs} must be non-negative. The existing contents of \code{f} are not altered if they still fit in the new size.
\end{quote}

\begin{lstlisting}
void fmpz_clear(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Free space used by the \code{fmpz_t f}.
\end{quote}

\subsection{Random numbers}

\begin{lstlisting}
void fmpz_random_limbs2(fmpz_t x, unsigned long n)
\end{lstlisting}
\begin{quote}
Set \code{x} to a random number of $n$ limbs consisting of long strings of ones and zeroes.
\end{quote}

\subsection{String operations}

\begin{lstlisting}
void fmpz_print(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Print the multiprecision integer \code{f}. A minus sign is prepended if the integer is negative.
\end{quote}

\subsection{fmpz properties}

\begin{lstlisting}
unsigned long fmpz_size(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Return the number of limbs used to store the absolute value of the multiprecision integer \code{f}.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_bits(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Return the number of bits required to store the absolute value of the multiprecision integer \code{f}.
\end{quote}

\begin{lstlisting}
long fmpz_sgn(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Return the sign/size limb of the multiprecision integer \code{f}. The sign of the sign/size limb is the sign of the multiprecision integer. The absolute value of the sign/size limb is the size in limbs of the absolute value of the multiprecision integer \code{f}. 
\end{quote}

\subsection{Assignment}

\begin{lstlisting}
void fmpz_set_ui(fmpz_t res, unsigned long x)
\end{lstlisting}
\begin{quote}
Set the multiprecision integer \code{res} to the \code{unsigned long x}.
\end{quote}

\begin{lstlisting}
void fmpz_set_si(fmpz_t res, long x)
\end{lstlisting}
\begin{quote}
Set the multiprecision integer \code{res} to the \code{long x}.
\end{quote}

\begin{lstlisting}
void fmpz_set(fmpz_t res, const fmpz_t f)
\end{lstlisting}
\begin{quote}
Set the multiprecision integer \code{res} to equal the multiprecision integer \code{f}.
\end{quote}

\subsection{Comparison}

\begin{lstlisting}
int fmpz_equal(const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Return 1 if \code{f1} is equal to \code{f2}, otherwise return 0.
\end{quote}

\begin{lstlisting}
int fmpz_is_one(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Return 1 if \code{f} is one, otherwise return 0.
\end{quote}

\begin{lstlisting}
int fmpz_is_zero(const fmpz_t f)
\end{lstlisting}
\begin{quote}
Return 1 if \code{f} is zero, otherwise return 0.
\end{quote}

\begin{lstlisting}
int fmpz_cmpabs(const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Compares the absolute values of \code{f1} and \code{f2}. If the absolute value of \code{f1} is less than that of \code{f2} then a negative value is returned. If the absolute value of \code{f1} is greater than that of \code{f2} then a positive value is returned. If the absolute values are equal, then zero is returned. 
\end{quote}

\subsection{Conversion}

\begin{lstlisting}
void mpz_to_fmpz(fmpz_t res, const mpz_t x)
\end{lstlisting}
\begin{quote}
Convert the \code{mpz_t x} to the \code{fmpz_t res}. 
\end{quote}

\begin{lstlisting}
void fmpz_to_mpz(mpz_t res, const fmpz_t f)
\end{lstlisting}
\begin{quote}
Convert the \code{fmpz_t f} to the \code{mpz_t res}. 
\end{quote}

\subsection{Addition/subtraction}

\begin{lstlisting}
void fmpz_add(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to the sum of \code{f1} and \code{f2}.
\end{quote}

\begin{lstlisting}
void fmpz_add_ui_inplace(fmpz_t res, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to the sum of \code{res} and the \code{unsigned long x}.
\end{quote}

\begin{lstlisting}
void fmpz_add_ui(fmpz_t res, const fmpz_t f, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to the sum of \code{f} and the \code{unsigned long x}.
\end{quote}

\begin{lstlisting}
void fmpz_sub(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{f1} minus \code{f2}.
\end{quote}

\begin{lstlisting}
void fmpz_sub_ui_inplace(fmpz_t res, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{res} minus the \code{unsigned long x}.
\end{quote}

\begin{lstlisting}
void fmpz_sub_ui(fmpz_t res, const fmpz_t f, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{f} minus the \code{unsigned long x}.
\end{quote}

\subsection{Multiplication}

\begin{lstlisting}
void fmpz_mul(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{f1} times \code{f2}.
\end{quote}

\begin{lstlisting}
void fmpz_mul_ui(fmpz_t res, const fmpz_t f1, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{f1} times the \code{unsigned long x}.
\end{quote}

\begin{lstlisting}
void fmpz_mul_2exp(fmpz_t output, fmpz_t x, unsigned long exp)
\end{lstlisting}
\begin{quote}
Multiply \code{x} by $2^{\mbox{exp}}$.
\end{quote}

\begin{lstlisting}
void fmpz_addmul(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{res + f1 * f2}.
\end{quote}

\subsection{Division}

\begin{lstlisting}
void fmpz_tdiv(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to the quotient of \code{f1} by \code{f2}. Round the quotient towards zero and discard the remainder.
\end{quote}

\begin{lstlisting}
void fmpz_fdiv(fmpz_t res, const fmpz_t f1, const fmpz_t f2)
\end{lstlisting}
\begin{quote}
Set \code{res} to the quotient of \code{f1} by \code{f2}. Round the quotient towards minus infinity and discard the remainder.
\end{quote}

\begin{lstlisting}
void fmpz_tdiv_ui(fmpz_t res, const fmpz_t f1, unsigned long x)
\end{lstlisting}
\begin{quote}
Set \code{res} to the quotient of \code{f1} by the unsigned long \code{x}. Round the quotient towards zero and discard the remainder.
\end{quote}

\begin{lstlisting}
void fmpz_div_2exp(fmpz_t output, fmpz_t x, unsigned long exp)
\end{lstlisting}
\begin{quote}
Divide \code{x} by $2^{\mbox{exp}}$, returning the quotient and discarding the remainder.
\end{quote}

\begin{lstlisting}
unsigned long fmpz_mod_ui(const fmpz_t input, const unsigned long x)
\end{lstlisting}
\begin{quote}
Returns \code{f1} modulo the \code{unsigned long x}. Note that \code{f1} may be unsigned. 
\end{quote}

\subsection{Powering}

\begin{lstlisting}
void fmpz_pow_ui(fmpz_t res, const fmpz_t f, unsigned long exp)
\end{lstlisting}
\begin{quote}
Set \code{res} to \code{f} raised to the power \code{exp}. This requires \code{exp} to be non-negative.
\end{quote}

\subsection{Root extraction}

\begin{lstlisting}
void fmpz_sqrtrem(fmpz_t sqrt, fmpz_t rem, fmpz_t x)
\end{lstlisting}
\begin{quote}
Computes the square root of \code{x} and returns the integer part of the square root, \code{sqrt}, and the remainder, \code{rem = x - sqrt^2}. 

Note that \code{x} must be non-negative, else an exception is raised.
\end{quote}

\subsection{Number theoretical}

\begin{lstlisting}
void fmpz_gcd(fmpz_t output, fmpz_t x1, fmpz_t x2)
\end{lstlisting}
\begin{quote}
Compute the greatest common divisor of \code{x1} and \code{x2}. The result is always non-negative and will be zero if both of the inputs are zero.
\end{quote}

\subsection{Chinese remaindering}
\begin{lstlisting}
void fmpz_CRT_ui_precomp(fmpz_t x, fmpz_t r1, fmpz_t m1, unsigned long r2,
                             unsigned long m2, unsigned long c, pre_inv_t pre)
void fmpz_CRT_ui2_precomp(fmpz_t x, fmpz_t r1, fmpz_t m1, unsigned long r2,
                            unsigned long m2, unsigned long c, pre_inv2_t pre)
\end{lstlisting}
\begin{quote}
Computes the unique value \code{x} modulo \code{m1*m2} that is \code{r1} modulo \code{m1} and \code{r2} modulo \code{m2}. Requires \code{m1} and \code{m2} to be coprime, \code{c} to be set to the value \code{m1} modulo \code{m2} and \code{pre} to be a precomputed inverse of \code{m2} (computed using \code{z_precompute_inverse(m2)}). 

The first version of the function requires that \code{m2} be no more than \code{FLINT_D_BITS} bits, whereas the second version requires \code{m2} to be no more than \code{FLINT_BITS - 1} bits.
\end{quote}

\section{NTL interface}
Various functions are provided for converting between FLINT objects and NTL objects. To make use of these functions one must type:

\code{#include "NTL-interface.h"}

In each case the functions provided for conversion expect the output objects, whether NTL or FLINT objects, to be initialised. However the functions are managed, in that a reallocation automatically occurs if insufficient space was allocated by the user.

\begin{lstlisting}
void ZZ_to_fmpz(fmpz_t output, const ZZ& z)
\end{lstlisting}
\begin{quote}
Convert an NTL \code{ZZ} integer object to a FLINT \code{fmpz_t} integer object.
\end{quote}

\begin{lstlisting}
void fmpz_to_ZZ(ZZ& output, const fmpz_t z)
\end{lstlisting}
\begin{quote}
Convert a FLINT \code{fmpz_t} integer object to an NTL \code{ZZ} integer object.
\end{quote}

\begin{lstlisting}
void fmpz_poly_to_ZZX(ZZX& output, const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Convert an NTL \code{ZZX} polynomial object to a FLINT \code{fmpz_poly_t} polynomial object.
\end{quote}

\begin{lstlisting}
void fmpz_poly_to_ZZX(ZZX& output, const fmpz_poly_t poly)
\end{lstlisting}
\begin{quote}
Convert a FLINT \code{fmpz_poly_t} polynomial object to an NTL \code{ZZX} polynomial object.
\end{quote}

\section{The quadratic sieve}
Currently the quadratic sieve is a standalone program which can be built by typing:

\code{make QS}

in the main FLINT directory.

The program is called \code{mpQS}. Upon running it, one enters the number to be factored at the prompt. 

The quadratic sieve requires that the number entered not be a prime, not be a perfect power and it must not have very small factors. Trial division and the elliptic curve method should be run before making a call to the quadratic sieve, to remove small factors. The sieve may fail silently if the conditions are not met or if the number is too small to be factored by the quadratic sieve (currently about 20 decimal digits or below).

\section{Large integer multiplication}
In the module \code{mpn_extras} and \code{mpz_extras} are functions \code{F_mpn_mul} and \code{F_mpz_mul} respectively which are drop in replacements for GMP's \code{mpn_mul} and \code{mpz_mul} respectively. 

These replacement functions are substantially faster than GMP 4.2.1 when multiplying integers which are thousands of limbs in size. For smaller multiplications these functions call their respective GMP counterparts.

\bibliographystyle{amsalpha}
\bibliography{flint}

\end{document}
